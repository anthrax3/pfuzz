#!/usr/bin/python

import sys
import re
from optparse import OptionParser

#load the plugin
def load_plugin(name):
    mod = __import__("pf6mod_%s" % name)
    return mod

#get the plugin info
def call_plugin_info(name):
    plugin = load_plugin(name)
    return [plugin.plugin_description(), plugin.plugin_usage()]

#call the plugin
def call_plugin(name, *args):
    plugin = load_plugin(name)
    return plugin.plugin_main(*args)
    
def h_iter(sStart, sEnd):
    output = []
    try:
        iStart = int(sStart, 16)
        iEnd = int (sEnd, 16)
        if (iEnd > iStart):
            for i in range(iStart, iEnd+1):
                #print "%s %s %i" % (hex(i), hex(i)[2:],i)
                output.append(hex(i)[2:])
                #print output
        else:
            print "Hex is backwards"
            sys.exit(0)
    except ValueError:
        print "Invalid hex specified"
        sys.exit(0)
    
    return output
        

def prefix_parse(prefix):
    prefixes = []
    reHRange = re.compile("\[([a-fA-F0-9]{1,4})\-([a-fA-F0-9]{1,4})\]")
    try:
	m = reHRange.findall(prefix)
	if (len(m) == 0):
	    oPrefixes = [prefix]
	else:
	    lPrefixes = []
	    oPrefixes = []
	    lPrefixes.append(prefix)
	    for reT in m:
		oPrefixes = []
		lIters = h_iter(reT[0],reT[1])
		for lIterable in lIters:
		    for t_prefix in lPrefixes:
			oPrefixes.append(t_prefix.replace("[%s-%s]" % (reT[0], reT[1]),lIterable,1))
		lPrefixes = oPrefixes
    except TypeError:
        pass
    return oPrefixes

#make sure prefix is valid
def prefix_sanitize(prefix):
    #check v6 address format
    # 2 acceptable inputs - fully qualified, or prefix notation
    bValid = False
    
    reSAddr = re.compile("[0-9A-F]{1,4}:[0-9A-F]{1,4}:[0-9A-F]{1,4}:[0-9A-F]{1,4}:[0-9A-F]{1,4}:[0-9A-F]{1,4}:[0-9A-F]{1,4}:")
    try:
        if (reSAddr.match(prefix)):
            #match for long format
            bValid = True
    except TypeError:
        bValid = False
    try:
        if (prefix[len(prefix)-2] == "::"):
            #match for prefix
            bValid = True
    except TypeError:
        bValid = False
    
    
    return bValid


#optparse related functions
def optp_module_callback(option, opt, value, parser):
  setattr(parser.values, option.dest, value.split(','))

        
################
#entrypoint
################

pfuzz_logo = """

           $$$$$$\                                
          $$  __$$\                               
 $$$$$$\  $$ /  \__|$$\   $$\ $$$$$$$$\ $$$$$$$$\ 
$$  __$$\ $$$$\     $$ |  $$ |\____$$  |\____$$  |
$$ /  $$ |$$  _|    $$ |  $$ |  $$$$ _/   $$$$ _/ 
$$ |  $$ |$$ |      $$ |  $$ | $$  _/    $$  _/   
$$$$$$$  |$$ |      \$$$$$$  |$$$$$$$$\ $$$$$$$$\ 
$$  ____/ \__|       \______/ \________|\________|
$$ |                                              
$$ |                                              
\__|	a project of the dragon research group                                              

"""



#versioning information
prefix = ""
installed_plugins = ["dhcp","ports","mac"]
plugins = ["dhcp","ports"]
addrs = []

#handle command line arguments
oparser = OptionParser()
oparser.add_option("-m", "--module", action="callback", dest="module", default="dhcp", callback=optp_module_callback, help="specify the generation module to use. multiple modules should be seperated with commas")
oparser.add_option("-l", "--list-modules", action="store_true", dest="module_list", default=False, help="List module information")
oparser.add_option("--mac-org", action="store", dest="mac_org", default="", help="Organization to check MACs against")
(options, args) = oparser.parse_args()

#removed argparse functionality to support python 2.6 by default. optparse is deprecated in 2.7 so argparse code will be retained until 2.7 becomes the primary distribution
#parser = argparse.ArgumentParser(description = "an ipv6 prefix fuzzer", epilog="For more information visit www.dragonresearchgroup.org/pfuzz")
#parser.add_argument("prefix", nargs="?", help="prefix to fuzz")
#parser.add_argument('--module', action="store", help = "specify a module to use")
#parser.add_argument('--module-list', dest="module_list", action="store_true", default=False, help="List modules installed")

#mac module arguments
#g_mac = parser.add_argument_group('mac','MAC module options')
#g_mac.add_argument("--mac-org", dest="mac_org", action="store", default = "", help = "Organization to check MACs against")

#parse arguments
#args = parser.parse_args()

#do they want us to list the modules
#if (args.module_list == True):
if (options.module_list == True):
	print pfuzz_logo
	print "Installed Modules:"
	for it_plugin in installed_plugins:
	    print "\n *** %s *** " % it_plugin
	    plugin_info = call_plugin_info(it_plugin)
	    print "description:\n%s\n" % plugin_info[0]
	    print "usage:\n%s" % plugin_info[1]
	sys.exit(0)

#make sure the prefix is specified
if (args[0] == None):
	print "You must specify a prefix"
	sys.exit(0)


#grab the prefix
prefixes = prefix_parse(args[0])
#print prefixes
    
#is a parser set?
if (len(options.module) > 0):
    plugins = [options.module]
    
#iterate over prefixes
for prefix in prefixes:
    #iterate over plugins
    for plugin in plugins:
        plugin_addrs = call_plugin(plugin, prefix, args)
        if plugin_addrs != None:
            for addr in plugin_addrs:
                addrs.append(addr)

#PERF remove duplicates
finalized_addrs = list(set(addrs))

#PERF
#output options
for addr in finalized_addrs:
    print addr
